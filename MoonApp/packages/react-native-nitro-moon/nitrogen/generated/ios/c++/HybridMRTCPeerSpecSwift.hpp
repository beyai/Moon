///
/// HybridMRTCPeerSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridMRTCPeerSpec.hpp"

// Forward declaration of `HybridMRTCPeerSpec_cxx` to properly resolve imports.
namespace NitroMoon { class HybridMRTCPeerSpec_cxx; }

// Forward declaration of `MRTCSessionDescription` to properly resolve imports.
namespace margelo::nitro::nitromoon { struct MRTCSessionDescription; }
// Forward declaration of `MRTCSdpType` to properly resolve imports.
namespace margelo::nitro::nitromoon { enum class MRTCSdpType; }
// Forward declaration of `MRTCIceCandidate` to properly resolve imports.
namespace margelo::nitro::nitromoon { struct MRTCIceCandidate; }
// Forward declaration of `MRTCMessageType` to properly resolve imports.
namespace margelo::nitro::nitromoon { enum class MRTCMessageType; }
// Forward declaration of `MRTCDataChannelMessage` to properly resolve imports.
namespace margelo::nitro::nitromoon { struct MRTCDataChannelMessage; }
// Forward declaration of `MRTCActionTypes` to properly resolve imports.
namespace margelo::nitro::nitromoon { enum class MRTCActionTypes; }
// Forward declaration of `MRTCPeerConfig` to properly resolve imports.
namespace margelo::nitro::nitromoon { struct MRTCPeerConfig; }
// Forward declaration of `MRTCIceServer` to properly resolve imports.
namespace margelo::nitro::nitromoon { struct MRTCIceServer; }
// Forward declaration of `MRTCPeerState` to properly resolve imports.
namespace margelo::nitro::nitromoon { enum class MRTCPeerState; }
// Forward declaration of `MRTCDataChannelState` to properly resolve imports.
namespace margelo::nitro::nitromoon { enum class MRTCDataChannelState; }

#include <NitroModules/Promise.hpp>
#include "MRTCSessionDescription.hpp"
#include "MRTCSdpType.hpp"
#include <string>
#include "MRTCIceCandidate.hpp"
#include "MRTCMessageType.hpp"
#include "MRTCDataChannelMessage.hpp"
#include "MRTCActionTypes.hpp"
#include <NitroModules/AnyMap.hpp>
#include <functional>
#include "MRTCPeerConfig.hpp"
#include "MRTCIceServer.hpp"
#include <vector>
#include <optional>
#include "MRTCPeerState.hpp"
#include "MRTCDataChannelState.hpp"

#include "NitroMoon-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::nitromoon {

  /**
   * The C++ part of HybridMRTCPeerSpec_cxx.swift.
   *
   * HybridMRTCPeerSpecSwift (C++) accesses HybridMRTCPeerSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridMRTCPeerSpec_cxx can directly inherit from the C++ class HybridMRTCPeerSpec
   * to simplify the whole structure and memory management.
   */
  class HybridMRTCPeerSpecSwift: public virtual HybridMRTCPeerSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridMRTCPeerSpecSwift(const NitroMoon::HybridMRTCPeerSpec_cxx& swiftPart):
      HybridObject(HybridMRTCPeerSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline NitroMoon::HybridMRTCPeerSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    

  public:
    // Methods
    inline std::shared_ptr<Promise<void>> start() override {
      auto __result = _swiftPart.start();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> close() override {
      auto __result = _swiftPart.close();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void addRemoteDescription(const MRTCSessionDescription& desc) override {
      auto __result = _swiftPart.addRemoteDescription(std::forward<decltype(desc)>(desc));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void addIceCandidate(const MRTCIceCandidate& candidate) override {
      auto __result = _swiftPart.addIceCandidate(std::forward<decltype(candidate)>(candidate));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void sendDataChannelMessage(const MRTCDataChannelMessage& message) override {
      auto __result = _swiftPart.sendDataChannelMessage(std::forward<decltype(message)>(message));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::function<void()> onPeerConfig(const std::function<void(const MRTCPeerConfig& /* config */)>& listener) override {
      auto __result = _swiftPart.onPeerConfig(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> onPeerStateChange(const std::function<void(MRTCPeerState /* state */)>& listener) override {
      auto __result = _swiftPart.onPeerStateChange(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> onLocalDescription(const std::function<void(const MRTCSessionDescription& /* desc */)>& listener) override {
      auto __result = _swiftPart.onLocalDescription(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> onLocalCandidate(const std::function<void(const MRTCIceCandidate& /* candidate */)>& listener) override {
      auto __result = _swiftPart.onLocalCandidate(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> onDataChannelStateChange(const std::function<void(MRTCDataChannelState /* state */)>& listener) override {
      auto __result = _swiftPart.onDataChannelStateChange(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> onDataChannelMessage(const std::function<void(const MRTCDataChannelMessage& /* message */)>& listener) override {
      auto __result = _swiftPart.onDataChannelMessage(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }

  private:
    NitroMoon::HybridMRTCPeerSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::nitromoon
