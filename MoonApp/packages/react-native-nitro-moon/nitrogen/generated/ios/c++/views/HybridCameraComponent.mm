///
/// HybridCameraComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#import "HybridCameraComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridCameraSpecSwift.hpp"
#import "NitroMoon-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::nitromoon;
using namespace margelo::nitro::nitromoon::views;

/**
 * Represents the React Native View holder for the Nitro "Camera" HybridView.
 */
@interface HybridCameraComponent: RCTViewComponentView
@end

@implementation HybridCameraComponent {
  std::shared_ptr<HybridCameraSpecSwift> _hybridView;
}

+ (void) load {
  [super load];
  [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridCameraComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
  return react::concreteComponentDescriptorProvider<HybridCameraComponentDescriptor>();
}

- (instancetype) init {
  if (self = [super init]) {
    std::shared_ptr<HybridCameraSpec> hybridView = NitroMoon::NitroMoonAutolinking::createCamera();
    _hybridView = std::dynamic_pointer_cast<HybridCameraSpecSwift>(hybridView);
    [self updateView];
  }
  return self;
}

- (void) updateView {
  // 1. Get Swift part
  NitroMoon::HybridCameraSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Get UIView*
  void* viewUnsafe = swiftPart.getView();
  UIView* view = (__bridge_transfer UIView*) viewUnsafe;

  // 3. Update RCTViewComponentView's [contentView]
  [self setContentView:view];
}

- (void) updateProps:(const std::shared_ptr<const react::Props>&)props
            oldProps:(const std::shared_ptr<const react::Props>&)oldProps {
  // 1. Downcast props
  const auto& newViewPropsConst = *std::static_pointer_cast<HybridCameraProps const>(props);
  auto& newViewProps = const_cast<HybridCameraProps&>(newViewPropsConst);
  NitroMoon::HybridCameraSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Update each prop individually
  swiftPart.beforeUpdate();

  // isActive: boolean
  if (newViewProps.isActive.isDirty) {
    swiftPart.setIsActive(newViewProps.isActive.value);
    newViewProps.isActive.isDirty = false;
  }
  // preview: boolean
  if (newViewProps.preview.isDirty) {
    swiftPart.setPreview(newViewProps.preview.value);
    newViewProps.preview.isDirty = false;
  }
  // filter: struct
  if (newViewProps.filter.isDirty) {
    swiftPart.setFilter(newViewProps.filter.value);
    newViewProps.filter.isDirty = false;
  }
  // fps: number
  if (newViewProps.fps.isDirty) {
    swiftPart.setFps(newViewProps.fps.value);
    newViewProps.fps.isDirty = false;
  }
  // zoom: number
  if (newViewProps.zoom.isDirty) {
    swiftPart.setZoom(newViewProps.zoom.value);
    newViewProps.zoom.isDirty = false;
  }
  // focus: number
  if (newViewProps.focus.isDirty) {
    swiftPart.setFocus(newViewProps.focus.value);
    newViewProps.focus.isDirty = false;
  }
  // exposure: number
  if (newViewProps.exposure.isDirty) {
    swiftPart.setExposure(newViewProps.exposure.value);
    newViewProps.exposure.isDirty = false;
  }
  // brightness: number
  if (newViewProps.brightness.isDirty) {
    swiftPart.setBrightness(newViewProps.brightness.value);
    newViewProps.brightness.isDirty = false;
  }
  // orientation: enum
  if (newViewProps.orientation.isDirty) {
    swiftPart.setOrientation(static_cast<int>(newViewProps.orientation.value));
    newViewProps.orientation.isDirty = false;
  }
  // onInitialized: optional
  if (newViewProps.onInitialized.isDirty) {
    swiftPart.setOnInitialized(newViewProps.onInitialized.value);
    newViewProps.onInitialized.isDirty = false;
  }
  // onChangeDevice: optional
  if (newViewProps.onChangeDevice.isDirty) {
    swiftPart.setOnChangeDevice(newViewProps.onChangeDevice.value);
    newViewProps.onChangeDevice.isDirty = false;
  }

  swiftPart.afterUpdate();

  // 3. Update hybridRef if it changed
  if (newViewProps.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = newViewProps.hybridRef.value;
    if (maybeFunc.has_value()) {
      maybeFunc.value()(_hybridView);
    }
    newViewProps.hybridRef.isDirty = false;
  }

  // 4. Continue in base class
  [super updateProps:props oldProps:oldProps];
}

@end
