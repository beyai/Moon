///
/// NitroMoon-Swift-Cxx-Bridge.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#include "NitroMoon-Swift-Cxx-Bridge.hpp"

// Include C++ implementation defined types
#include "HybridCameraSpecSwift.hpp"
#include "HybridDetectionSpecSwift.hpp"
#include "HybridHttpRequestSpecSwift.hpp"
#include "HybridMRTCPeerSpecSwift.hpp"
#include "HybridMRTCSpecSwift.hpp"
#include "HybridQRScanerSpecSwift.hpp"
#include "HybridSignalSpecSwift.hpp"
#include "HybridSoundManagerSpecSwift.hpp"
#include "HybridSoundPlayerSpecSwift.hpp"
#include "HybridSoundTTSSpecSwift.hpp"
#include "HybridToolSpecSwift.hpp"
#include "NitroMoon-Swift-Cxx-Umbrella.hpp"
#include <NitroModules/NitroDefines.hpp>

namespace margelo::nitro::nitromoon::bridge::swift {

  // pragma MARK: std::function<void()>
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)]() mutable -> void {
      swiftClosure.call();
    };
  }
  
  // pragma MARK: std::function<void(const CameraFormat& /* format */)>
  Func_void_CameraFormat create_Func_void_CameraFormat(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_CameraFormat::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const CameraFormat& format) mutable -> void {
      swiftClosure.call(format);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridCameraSpec>
  std::shared_ptr<HybridCameraSpec> create_std__shared_ptr_HybridCameraSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridCameraSpec_cxx swiftPart = NitroMoon::HybridCameraSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridCameraSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridCameraSpec_(std__shared_ptr_HybridCameraSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridCameraSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridCameraSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridCameraSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridCameraSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_std__exception_ptr::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::exception_ptr& error) mutable -> void {
      swiftClosure.call(error);
    };
  }
  
  // pragma MARK: std::function<void(const DetectionResult& /* results */)>
  Func_void_DetectionResult create_Func_void_DetectionResult(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_DetectionResult::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const DetectionResult& results) mutable -> void {
      swiftClosure.call(results);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridDetectionSpec>
  std::shared_ptr<HybridDetectionSpec> create_std__shared_ptr_HybridDetectionSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridDetectionSpec_cxx swiftPart = NitroMoon::HybridDetectionSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridDetectionSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridDetectionSpec_(std__shared_ptr_HybridDetectionSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridDetectionSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridDetectionSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridDetectionSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridDetectionSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const ResponseResult& /* result */)>
  Func_void_ResponseResult create_Func_void_ResponseResult(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_ResponseResult::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const ResponseResult& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridHttpRequestSpec>
  std::shared_ptr<HybridHttpRequestSpec> create_std__shared_ptr_HybridHttpRequestSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridHttpRequestSpec_cxx swiftPart = NitroMoon::HybridHttpRequestSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridHttpRequestSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridHttpRequestSpec_(std__shared_ptr_HybridHttpRequestSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridHttpRequestSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridHttpRequestSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridHttpRequestSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridHttpRequestSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridMRTCPeerSpec>
  std::shared_ptr<HybridMRTCPeerSpec> create_std__shared_ptr_HybridMRTCPeerSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridMRTCPeerSpec_cxx swiftPart = NitroMoon::HybridMRTCPeerSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridMRTCPeerSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridMRTCPeerSpec_(std__shared_ptr_HybridMRTCPeerSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridMRTCPeerSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridMRTCPeerSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridMRTCPeerSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridMRTCPeerSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridMRTCSpec>
  std::shared_ptr<HybridMRTCSpec> create_std__shared_ptr_HybridMRTCSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridMRTCSpec_cxx swiftPart = NitroMoon::HybridMRTCSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridMRTCSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridMRTCSpec_(std__shared_ptr_HybridMRTCSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridMRTCSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridMRTCSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridMRTCSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridMRTCSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const MRTCPeerConfig& /* config */)>
  Func_void_MRTCPeerConfig create_Func_void_MRTCPeerConfig(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_MRTCPeerConfig::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const MRTCPeerConfig& config) mutable -> void {
      swiftClosure.call(config);
    };
  }
  
  // pragma MARK: std::function<void(MRTCPeerState /* state */)>
  Func_void_MRTCPeerState create_Func_void_MRTCPeerState(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_MRTCPeerState::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](MRTCPeerState state) mutable -> void {
      swiftClosure.call(static_cast<int>(state));
    };
  }
  
  // pragma MARK: std::function<void(const MRTCSessionDescription& /* desc */)>
  Func_void_MRTCSessionDescription create_Func_void_MRTCSessionDescription(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_MRTCSessionDescription::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const MRTCSessionDescription& desc) mutable -> void {
      swiftClosure.call(desc);
    };
  }
  
  // pragma MARK: std::function<void(const MRTCIceCandidate& /* candidate */)>
  Func_void_MRTCIceCandidate create_Func_void_MRTCIceCandidate(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_MRTCIceCandidate::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const MRTCIceCandidate& candidate) mutable -> void {
      swiftClosure.call(candidate);
    };
  }
  
  // pragma MARK: std::function<void(MRTCDataChannelState /* state */)>
  Func_void_MRTCDataChannelState create_Func_void_MRTCDataChannelState(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_MRTCDataChannelState::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](MRTCDataChannelState state) mutable -> void {
      swiftClosure.call(static_cast<int>(state));
    };
  }
  
  // pragma MARK: std::function<void(const MRTCDataChannelMessage& /* message */)>
  Func_void_MRTCDataChannelMessage create_Func_void_MRTCDataChannelMessage(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_MRTCDataChannelMessage::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const MRTCDataChannelMessage& message) mutable -> void {
      swiftClosure.call(message);
    };
  }
  
  // pragma MARK: std::function<void(const std::string& /* result */)>
  Func_void_std__string create_Func_void_std__string(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_std__string::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::string& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridQRScanerSpec>
  std::shared_ptr<HybridQRScanerSpec> create_std__shared_ptr_HybridQRScanerSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridQRScanerSpec_cxx swiftPart = NitroMoon::HybridQRScanerSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridQRScanerSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridQRScanerSpec_(std__shared_ptr_HybridQRScanerSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridQRScanerSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridQRScanerSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridQRScanerSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridQRScanerSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(SignalState /* state */)>
  Func_void_SignalState create_Func_void_SignalState(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_SignalState::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](SignalState state) mutable -> void {
      swiftClosure.call(static_cast<int>(state));
    };
  }
  
  // pragma MARK: std::function<void(const SignalResponse& /* data */)>
  Func_void_SignalResponse create_Func_void_SignalResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_SignalResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const SignalResponse& data) mutable -> void {
      swiftClosure.call(data);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridSignalSpec>
  std::shared_ptr<HybridSignalSpec> create_std__shared_ptr_HybridSignalSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridSignalSpec_cxx swiftPart = NitroMoon::HybridSignalSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridSignalSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridSignalSpec_(std__shared_ptr_HybridSignalSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridSignalSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridSignalSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridSignalSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridSignalSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridSoundManagerSpec>
  std::shared_ptr<HybridSoundManagerSpec> create_std__shared_ptr_HybridSoundManagerSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridSoundManagerSpec_cxx swiftPart = NitroMoon::HybridSoundManagerSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridSoundManagerSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridSoundManagerSpec_(std__shared_ptr_HybridSoundManagerSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridSoundManagerSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridSoundManagerSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridSoundManagerSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridSoundManagerSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridSoundPlayerSpec>
  std::shared_ptr<HybridSoundPlayerSpec> create_std__shared_ptr_HybridSoundPlayerSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridSoundPlayerSpec_cxx swiftPart = NitroMoon::HybridSoundPlayerSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridSoundPlayerSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridSoundPlayerSpec_(std__shared_ptr_HybridSoundPlayerSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridSoundPlayerSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridSoundPlayerSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridSoundPlayerSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridSoundPlayerSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridSoundTTSSpec>
  std::shared_ptr<HybridSoundTTSSpec> create_std__shared_ptr_HybridSoundTTSSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridSoundTTSSpec_cxx swiftPart = NitroMoon::HybridSoundTTSSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridSoundTTSSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridSoundTTSSpec_(std__shared_ptr_HybridSoundTTSSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridSoundTTSSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridSoundTTSSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridSoundTTSSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridSoundTTSSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(CameraPermissionStatus /* result */)>
  Func_void_CameraPermissionStatus create_Func_void_CameraPermissionStatus(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_CameraPermissionStatus::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](CameraPermissionStatus result) mutable -> void {
      swiftClosure.call(static_cast<int>(result));
    };
  }
  
  // pragma MARK: std::function<void(double /* result */)>
  Func_void_double create_Func_void_double(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_double::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](double result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(bool /* result */)>
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroMoon::Func_void_bool::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](bool result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridToolSpec>
  std::shared_ptr<HybridToolSpec> create_std__shared_ptr_HybridToolSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroMoon::HybridToolSpec_cxx swiftPart = NitroMoon::HybridToolSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::nitromoon::HybridToolSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridToolSpec_(std__shared_ptr_HybridToolSpec_ cppType) {
    std::shared_ptr<margelo::nitro::nitromoon::HybridToolSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::nitromoon::HybridToolSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridToolSpec\" is not implemented in Swift!");
    }
    #endif
    NitroMoon::HybridToolSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }

} // namespace margelo::nitro::nitromoon::bridge::swift
