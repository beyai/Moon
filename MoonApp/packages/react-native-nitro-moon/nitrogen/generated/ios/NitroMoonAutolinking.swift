///
/// NitroMoonAutolinking.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

public final class NitroMoonAutolinking {
  public typealias bridge = margelo.nitro.nitromoon.bridge.swift

  /**
   * Creates an instance of a Swift class that implements `HybridCameraSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridCameraSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `Camera`).
   */
  public static func createCamera() -> bridge.std__shared_ptr_HybridCameraSpec_ {
    let hybridObject = Camera()
    return { () -> bridge.std__shared_ptr_HybridCameraSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridQRScanerSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridQRScanerSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `QRScaner`).
   */
  public static func createQRScaner() -> bridge.std__shared_ptr_HybridQRScanerSpec_ {
    let hybridObject = QRScaner()
    return { () -> bridge.std__shared_ptr_HybridQRScanerSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridToolSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridToolSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `Tool`).
   */
  public static func createTool() -> bridge.std__shared_ptr_HybridToolSpec_ {
    let hybridObject = Tool()
    return { () -> bridge.std__shared_ptr_HybridToolSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridSoundManagerSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridSoundManagerSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `SoundManager`).
   */
  public static func createSoundManager() -> bridge.std__shared_ptr_HybridSoundManagerSpec_ {
    let hybridObject = SoundManager()
    return { () -> bridge.std__shared_ptr_HybridSoundManagerSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridSoundPlayerSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridSoundPlayerSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `SoundPlayer`).
   */
  public static func createSoundPlayer() -> bridge.std__shared_ptr_HybridSoundPlayerSpec_ {
    let hybridObject = SoundPlayer()
    return { () -> bridge.std__shared_ptr_HybridSoundPlayerSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridSoundTTSSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridSoundTTSSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `SoundTTS`).
   */
  public static func createSoundTTS() -> bridge.std__shared_ptr_HybridSoundTTSSpec_ {
    let hybridObject = SoundTTS()
    return { () -> bridge.std__shared_ptr_HybridSoundTTSSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridHttpRequestSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridHttpRequestSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HttpRequest`).
   */
  public static func createHttpRequest() -> bridge.std__shared_ptr_HybridHttpRequestSpec_ {
    let hybridObject = HttpRequest()
    return { () -> bridge.std__shared_ptr_HybridHttpRequestSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridSignalSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridSignalSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `Signal`).
   */
  public static func createSignal() -> bridge.std__shared_ptr_HybridSignalSpec_ {
    let hybridObject = Signal()
    return { () -> bridge.std__shared_ptr_HybridSignalSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridMRTCSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridMRTCSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `MRTC`).
   */
  public static func createMRTC() -> bridge.std__shared_ptr_HybridMRTCSpec_ {
    let hybridObject = MRTC()
    return { () -> bridge.std__shared_ptr_HybridMRTCSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridDetectionSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridDetectionSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `Detection`).
   */
  public static func createDetection() -> bridge.std__shared_ptr_HybridDetectionSpec_ {
    let hybridObject = Detection()
    return { () -> bridge.std__shared_ptr_HybridDetectionSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
}
